<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>序列化</title>
    <link href="/2022/05/31/java%20%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/05/31/java%20%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="序列化定义"><a href="#序列化定义" class="headerlink" title="序列化定义"></a>序列化定义</h2><p>将一个类对象转换成可存储、可传输状态的过程。序列化有两个过程：</p><p>1、序列化：将对象编码成字节流（serializing）</p><p>2、反序列化：从字节流编码中重新构建对象（deserializing)。对象序列化后，可以在进程内&#x2F;进程间、网络间进行传输，也可以做本地持久化存储。</p><h2 id="为什么要序列化"><a href="#为什么要序列化" class="headerlink" title="为什么要序列化"></a>为什么要序列化</h2><p>系统底层并不认识对象，数据传输是以字节序列形式传递，以进程间通信为例，需要将对象转化为字节序列(字节序列中包括该对象的类型，成员信息等)，然后在目标进程里通过反序列化字节序列，将字节序列转换成对象。</p><h3 id="Serializable（Java自带）"><a href="#Serializable（Java自带）" class="headerlink" title="Serializable（Java自带）"></a>Serializable（Java自带）</h3><p>Serializable是序列化的意思，表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。</p><h3 id="Parcelable（android-专用）"><a href="#Parcelable（android-专用）" class="headerlink" title="Parcelable（android 专用）"></a>Parcelable（android 专用）</h3><p>除了Serializable之外，使用Parcelable也可以实现相同的效果，</p><p>不过不同于将对象进行序列化，Parcelable方式的实现原理是将一个完整的对象进行分解，</p><p>而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了。</p><h3 id="实现Parcelable的作用"><a href="#实现Parcelable的作用" class="headerlink" title="实现Parcelable的作用"></a>实现Parcelable的作用</h3><p>1）永久性保存对象，保存对象的字节序列到本地文件中；</p><p>2）通过序列化对象在网络中传递对象；</p><p>3）通过序列化在进程间传递对象。</p><h3 id="选择序列化方法的原则"><a href="#选择序列化方法的原则" class="headerlink" title="选择序列化方法的原则"></a>选择序列化方法的原则</h3><p>1）在使用内存的时候，Parcelable比Serializable性能高，所以推荐使用Parcelable。</p><p>2）Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。</p><p>3）Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。尽管Serializable效率低点，但此时还是建议使用Serializable 。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件研发流程</title>
    <link href="/2022/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%BD%AF%E4%BB%B6%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="软件产品开发流程："><a href="#软件产品开发流程：" class="headerlink" title="软件产品开发流程："></a>软件产品开发流程：</h2><p>下图所示的是一个软件产品开发大体上所需要经历的全部流程：</p><p><img src="/images/rjyflc.jpg"></p><h2 id="具体流程如下："><a href="#具体流程如下：" class="headerlink" title="具体流程如下："></a>具体流程如下：</h2><ol><li>启动<br>在项目启动阶段，主要确定项目的目标及其可行性。我们需要对项目的背景、干系人、解决的问题等等进行分析。并制定项目章程和组建项目团队，包括：产品经理、<a href="https://so.csdn.net/so/search?q=%E6%9E%B6%E6%9E%84&spm=1001.2101.3001.7020">架构</a>工程师、UI工程师、开发工程师、测试工程师等。完成以上准备工作之后，召开项目启动会，启动会结束后则进入下一步的工作。</li><li>规划<br>在项目的规划阶段，项目经理需要和项目需求方，以及项目的相关干系人确定项目的范围，创建WBS(<strong>把工作进行彻底分解，并梳理出其间的逻辑关系，利用整分合原则组织起来</strong>)，确定项目的里程碑和项目计划。同时制定项目的管理计划，包括成本，质量。风险等方面的预测和控制方案。</li><li>需求<br>在需求阶段，需要对采集的需求进行需求分析，编写PRD文档(<strong>PRD就是将宏观抽象化的业务，拆分成具体化的功能需求，并通过文字或图像等方式呈现出来</strong>)、UI设计、高保真设计。最后进入需求评审，评审通过则进入下一步的工作。</li><li>设计<br>在设计阶段，设计人员根据需求文档，对软件系统进行设计，包括数据结构、系统架构、业务模型及规则、流程控制、模块接口等。 输出概要设计，详细设计文档，以及数据库设计说明书等。</li><li>开发<br>在明确需求后，开发工程师正式进入编码阶段，根据产品原型图、UI效果图、设计文档，选择合适的开发环境、开发工具、开发语言等等进行实现，这个阶段也是个很长很难的阶段，也是软件实现的核心。</li><li>功能测试<br>对软件进行测试是保证软件质量的重要手段。开发工程师开发完成后，可以交由测试工程师测试。测试工程师测试到BUG要反馈给开发，开发进行修改。功能测试通常需要进行很多次，直到测试通过，达到质量要求。</li><li>端到端测试<br>在端到端测试阶段，测试人员根据完整的业务流程设计可以覆盖全流程的端到端测试案例，然后基于端到端案例对系统的各个模块进行全面测试，确保系统能够符合需求和验收质量标准。</li><li>用户验收测试<br>用户验收测试阶段，也是通常的UAT(User Acceptance Test)<strong>用户验收测试阶段</strong>，用户验收测试是最终用户可以检查软件是否符合业务要求的最后阶段。UAT由了解要求并了解构建软件目的的最终用户执行。此测试是在软件运行之前执行的最后一次测试。最终用户使用现实生活场景并为真实数据构建UAT测试用例，用户验收测试在最终用户在上线之前验证软件是否满足这些业务需求方面具有重要作用。</li><li>上线<br>所有测试通过，并与客户或者上级达成一致后，系统进行试运行，稳定后上线。<br>上线包括：上线部署、部署后验证、整理交付物（需求文档、设计文档、安装部署手册、产品帮助等等）和运维移交。</li><li>收尾<br>项目的收尾阶段，移交项目成果，释放项目团队，进行项目回顾总结，项目汇报，完成项目结项。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器种类</title>
    <link href="/2022/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A7%8D%E7%B1%BB/"/>
    <url>/2022/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A7%8D%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>服务器的种类是有很多种的，按照不同的属性划分种类也是不同的，从外形方面来划分，可以分为四种，分别是刀片服务器、机架式服务器、塔式服务器和机柜式服务器，下面我们详细的介绍一下这几种类型的服务器。 </p><h2 id="1、刀片服务器"><a href="#1、刀片服务器" class="headerlink" title="1、刀片服务器"></a>1、刀片服务器</h2><p>这种是比较常见的，主要是在标准的机架式机箱内安装多个卡式的服务器单元，这样可以实现高可用和高密度，每一个“刀片”其实就是一个系统主板。可以通过”板载”硬盘来实现操作系统的启动，这个就类似一个独立服务器，各个母板之间没有关联，各自运行各自的系统，服务不同的客户群。基于这种模式，管理员也可以将各个母板结合在一起，为共同的用户群服务，这样网络环境的速度是非常快的。 </p><p><img src="/images/dpfwq1.webp"></p><h2 id="2、机架式服务器"><a href="#2、机架式服务器" class="headerlink" title="2、机架式服务器"></a>2、机架式服务器</h2><p>这种服务器一般是功能型的，它外形比较像交换机，规格有1U、2U、4U等，安装在标准的19英寸机柜里面，其中1U规格的是最节省空间的。企业在选择主机的时候，会考虑体积、功耗、发热量等主机的物理参数，在有限的空间内如何能够更合理的布局自己的服务器是很重要的。1U的规格虽然很节省空间，但是性能也较差，4U以上的性能是很高的，可扩展性也很好。 </p><p>1U（ 1U&#x3D;1.75 英寸 ） 2U 4U 主要厚度会逐渐变大</p><p><img src="/images/jgsfwq1.webp"></p><h2 id="3、塔式服务器"><a href="#3、塔式服务器" class="headerlink" title="3、塔式服务器"></a>3、塔式服务器</h2><p>这种应该是大家见得最多的一种，它跟立式的PC很像，它的体积是比较大的，因为它的主板有很强的扩展性，插槽也很多，因此塔式服务器的主机机箱比标准的ATX机箱还要大。因为有足够的空间可以进行硬盘和电源的冗余扩展，应用范围也很广泛，不管是速度应用还是存储应用都可以使用这种服务器。 </p><h2 id="4、机柜式服务器"><a href="#4、机柜式服务器" class="headerlink" title="4、机柜式服务器"></a>4、机柜式服务器</h2><p>机柜式服务器一把你情况下是由机架式、刀片式服务器加上其他设备组合成的，内部设备比较多、比较复杂。对于证券、银行、邮电等重要企业，则应采用具有完备的故障自修复能力的系统，关键部件应采用冗余措施，对于关键业务使用的服务器也可以采用双机热备份高可用系统或者是高性能计算机，这样的系统可用性就可以得到很好的保证。 </p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机硬件组成</title>
    <link href="/2022/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90/"/>
    <url>/2022/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机硬件系统五大组成"><a href="#计算机硬件系统五大组成" class="headerlink" title="计算机硬件系统五大组成"></a>计算机硬件系统五大组成</h2><h3 id="1、控制器："><a href="#1、控制器：" class="headerlink" title="1、控制器："></a>1、控制器：</h3><p>​计算机的指挥系统。控制器通过地址访问存储器，从存储器中取出指令，经译码器分析后，根据指令分析结果产生相应的操作控制信号作用于其他部件，使得各部件在控制器控制下有条不紊地协调工作。</p><h3 id="2、运算器："><a href="#2、运算器：" class="headerlink" title="2、运算器："></a>2、运算器：</h3><p>​实现算术运算和逻辑运算的部件。</p><h3 id="3、存储器："><a href="#3、存储器：" class="headerlink" title="3、存储器："></a>3、存储器：</h3><p>​是计算机用来存放所有数据和程序的记忆部件。它的基本功能是按指定的地址存（写）入或者取（读）出信息。 计算机中的存储器可分成两大类：一类是内存储器，简称内存或主存；另一类是外存储器（辅助存储器），简称外存或辅存。 存储器由若干个存储单元组成，每个存储单元都有一个地址，计算机通过地址对存储单元进行读写。一个存储器所包含的字节数称为存储容量，单位有B、KB、MB、GB、TB等。</p><h3 id="4、输入设备："><a href="#4、输入设备：" class="headerlink" title="4、输入设备："></a>4、输入设备：</h3><p>​是向计算机中输入信息（程序、数据、声音、文字、图形、图像等）的设备。常见的输入设备有：键盘、鼠标、图形扫描仪、触摸屏、条形码输入器、光笔等。 外存储器也是一种输入设备。 </p><h3 id="5、输出设备："><a href="#5、输出设备：" class="headerlink" title="5、输出设备："></a>5、输出设备：</h3><p>​主要有显示器、打印机和绘图仪等。外存储器也当作一种输出设备。</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>​我们知道其实计算机是由五大单元：CPU（控制单元、算术逻辑单元）、主存储器、输入单元、输出单元构成的。也可以说CPU+主存储器+输入输出构成了电子计算机的三大核心组件</p><p>1、控制单元+算数逻辑单元&#x3D;&gt;CPU </p><p>2、主存储器，即内存</p><p>3、输入单元Input+输出单元Outpu&#x3D;&gt;IO设备</p><h3 id="处理器（CPU概念）"><a href="#处理器（CPU概念）" class="headerlink" title="处理器（CPU概念）"></a>处理器（CPU概念）</h3><p>​    通常将运算器和控制器合称为中央处理器(Central Processing Unit，CPU)。其中运算器用来主要负责程序运算与逻辑判断，控制器则主要协调各组件和各单元的工作，所以CPU的工作主要在于管理和运算。可以说计算机的大脑就是CPU，它从内存中<strong>取指令-&gt;解码-&gt;执行，</strong>然后再取指-&gt;解码-&gt;执行下一条指令，周而复始，直至整个程序被执行完成。  </p><pre><code class="hljs">     既然CPU的重点在于进行运算和判断，那么要被运算与判断的数据是从哪里来的？CPU读取的数据都是从主存储器（内存）来的！主存储器内的数据则是从输入单元所传输进来！而CPU处理完毕的数据也必须先写回主存储器中，最后数据才从主存储器传输到输出单元。</code></pre><p><img src="/images/jgsfwq2.jpg"></p><h3 id="1、寄存器"><a href="#1、寄存器" class="headerlink" title="1、寄存器"></a>1、寄存器</h3><p>cpu中也会有存储功能，这就是寄存器。因访问内存以得到指令或数据的时间比cpu执行指令花费的时间要长得多，所以，所有CPU内部都有一些用来保存关键变量和临时数据的寄存器，这样通常在cpu的指令集中专门提供一些指令，用来将一个字（可以理解为数据）从内存调入寄存器，以及将一个字从寄存器存入内存。cpu其他的指令集可以把来自寄存器、内存的操作数据组合，或者用两者产生一个结果，比如将两个字相加并把结果存在寄存器或内存中。</p><h3 id="2、64位"><a href="#2、64位" class="headerlink" title="2、64位"></a>2、64位</h3><p>cpu的位数指的是cpu一次性能从内存中取出多少位二进制指令，64bit指的是一次性能从内存中取出64位二进制指令。<br>    在2003年以前由Intel所开发的x86架构CPU由8位升级到16、32位，后来AMD依此架构修改新一代的CPU为64位，到现在，个人计算机CPU通常都是x86_64的架构。</p><p>cpu具有向下兼容性</p><h3 id="3、4核8线程"><a href="#3、4核8线程" class="headerlink" title="3、4核8线程"></a>3、4核8线程</h3><p>​它由 Intel 研发，是把处理器内部的一个物理CPU模拟成两个逻辑CPU（以后也许有多个），让单个处理器就能使用线程级的并行计算，进而兼容多线程操作系统和软件。超线程技术充分利用空闲CPU资源，在相同时间内完成更多工作，在一定程度上提高了运行效率和性能。<br>  所以才会出现了我们提到的四核八线程，也就是将四个物理核心模拟成八个逻辑核心，同时会有四核支持八线程的操作。<br>  但是呢，四核八线程虽然模拟出来的是八核，其实和真实八核区别很大，虽然采用超线程技术能同时执行两个线程，但它并不能像两个真实CPU那样，每个CPU都具有独立的资源。单一资源同时只能支持一个CPU占用，因此当这些资源闲置后另一个CPU才能继续占用。并且，单一核心模拟出的两个逻辑核心的单个性能会有所下降。</p><h3 id="储存器"><a href="#储存器" class="headerlink" title="储存器"></a>储存器</h3><p>​ 计算机中第二重要的就是存储了，所有人都意淫着存储：速度快（这样cpu的等待存储器的延迟就降低了）+容量大+价钱便宜。然后同时兼备三者是不可能的，所以有了如下的不同的处理方式 </p><p><img src="/images/jgsfwq3.png"></p><p> 存储器系统采用如上图的分层结构，顶层的存储器速度较高，容量较小，与底层的存储器相比每位的成本较高，其差别往往是十亿数量级的 </p><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>RAM:我们安装的qq、微信、爱奇艺都是运行的RAM内存</p><p>ROM: BIOS(Basic Input Output System基本的输入输出操作系统)  电脑自带基本的控制硬件系统（如图）</p><p><img src="/images/jgsfwq4.webp"></p><p>CMOS: 许多计算机利用CMOS存储器来<strong>保持当前时间和日期</strong>。CMOS存储器和递增时间的电路由一小块<strong>电池驱动</strong>，所以，即使计算机没有加电，时间也仍然可以正确地更新，除此之外<strong>CMOS还可以保存配置的参数，比如，哪一个是启动磁盘等</strong>，之所以采用CMOS是因为它耗电非常少，一块工厂原装电池往往能使用若干年，但是当电池失效时，相关的配置和时间等都将丢失 </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>程序的运行与计算机三大核心硬件cpu、内存、硬件的关系</p><p>1、程序最先是存放在硬盘中的</p><p>2、程序的运行需要先经历加载的过程：程序的代码&#x2F;数据从硬盘读入内存</p><p>3、然后cpu从内存中读取指令来运行</p><p>安装软件都是先装到硬盘中，软件的运行都要把数据加载到内存中。所以说计算机硬盘的大小决定了能够安装的软件数目，而计算机内容的大小决定了计算机能够同时运行的软件数目</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络基础</title>
    <link href="/2022/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p> 计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。因为不同用户的数据终端可能采取的字符集是不同的，两者需要进行通信，必须要在一定的标准上进行。一个很形象地比喻就是我们的语言，我们大天朝地广人多，地方性语言也非常丰富，而且方言之间差距巨大。A地区的方言可能B地区的人根本无法接受，所以我们要为全国人名进行沟通建立一个语言标准，这就是我们的普通话的作用。同样，放眼全球，我们与外国友人沟通的标准语言是英语，所以我们才要苦逼的学习英语。</p><p>计算机网络协议同我们的语言一样，多种多样。而ARPA公司与1977年到1979年推出了一种名为ARPANET的网络协议受到了广泛的热捧，其中最主要的原因就是它推出了人尽皆知的TCP&#x2F;IP标准网络协议。目前TCP&#x2F;IP协议已经成为Internet中的”通用语言”，下图为不同计算机群之间利用TCP&#x2F;IP进行通信的示意图。</p><h2 id="1-网络层次划分"><a href="#1-网络层次划分" class="headerlink" title="1. 网络层次划分"></a><strong>1. 网络层次划分</strong></h2><p> 互联网协议按照功能不同分为osi七层或tcp&#x2F;ip五层或tcp&#x2F;ip四层 </p><p><img src="/images/wljc1.jpg"></p><p> 每层运行常见物理设备 </p><p><img src="/images/wljc2.jpg"></p><p> OSI七层协议数据传输的封包与解包过程  </p><p><img src="/images/wljc3.jpg"></p><h2 id="2、-tcp-x2F-ip五层模型讲解"><a href="#2、-tcp-x2F-ip五层模型讲解" class="headerlink" title="2、 tcp&#x2F;ip五层模型讲解"></a>2、 tcp&#x2F;ip五层模型讲解</h2><p>我们将应用层，表示层，会话层并作应用层，从tcp／ip五层协议的角度来阐述每层的由来与功能，搞清楚了每层的主要协议</p><p>就理解了整个互联网通信的原理。</p><p>首先，用户感知到的只是最上面一层应用层，自上而下每层都依赖于下一层，所以我们从最下一层开始切入，比较好理解</p><p>每层都运行特定的协议，越往上越靠近用户，越往下越靠近硬件</p><h3 id="2-1、物理层"><a href="#2-1、物理层" class="headerlink" title="2.1、物理层"></a>2.1、物理层</h3><p> 物理层由来：上面提到，孤立的计算机之间要想一起玩，就必须接入internet，言外之意就是计算机之间必须完成组网 </p><p><img src="/images/wljc4.jpg"></p><p> 物理层功能：主要是基于电器特性发送高低电压(电信号)，高电压对应数字1，低电压对应数字0 </p><h3 id="2-2、数据链路层"><a href="#2-2、数据链路层" class="headerlink" title="2.2、数据链路层"></a>2.2、数据链路层</h3><p>数据链路层由来：单纯的电信号0和1没有任何意义，必须规定电信号多少位一组，每组什么意思</p><p>数据链路层的功能：定义了电信号的分组方式</p><h4 id="以太网协议："><a href="#以太网协议：" class="headerlink" title="以太网协议："></a>以太网协议：</h4><p>早期的时候各个公司都有自己的分组方式，后来形成了统一的标准，即以太网协议ethernet</p><p>ethernet规定</p><ul><li>一组电信号构成一个数据包，叫做‘帧’</li><li>每一数据帧分成：报头head和数据data两部分</li></ul><p>head包含：(固定18个字节)</p><ul><li>发送者／源地址，6个字节</li><li>接收者／目标地址，6个字节</li><li>数据类型，6个字节</li></ul><p>data包含：(最短46字节，最长1500字节)</p><ul><li>数据包的具体内容</li></ul><p>head长度＋data长度＝最短64字节，最长1518字节，超过最大限制就分片发送</p><h4 id="mac地址："><a href="#mac地址：" class="headerlink" title="mac地址："></a>mac地址：</h4><p>head中包含的源和目标地址由来：ethernet规定接入internet的设备都必须具备网卡，发送端和接收端的地址便是指网卡的地址，即mac地址</p><p>mac地址：每块网卡出厂时都被烧制上一个世界唯一的mac地址，长度为48位2进制，通常由12位16进制数表示（前六位是厂商编号，后六位是流水线号）</p><h4 id="广播："><a href="#广播：" class="headerlink" title="广播："></a>广播：</h4><p>有了mac地址，同一网络内的两台主机就可以通信了（一台主机通过arp协议获取另外一台主机的mac地址）</p><p>ethernet采用最原始的方式，广播的方式进行通信，即计算机通信基本靠吼</p><p><img src="/images/wljc5.jpg"></p><h3 id="2-3、网络层"><a href="#2-3、网络层" class="headerlink" title="2.3、网络层"></a>2.3、网络层</h3><p>网络层由来：有了ethernet、mac地址、广播的发送方式，世界上的计算机就可以彼此通信了，问题是世界范围的互联网是由</p><p>一个个彼此隔离的小的局域网组成的，那么如果所有的通信都采用以太网的广播方式，那么一台机器发送的包全世界都会收到，</p><p>这就不仅仅是效率低的问题了，这会是一种灾难</p><p><img src="/images/wljc6.jpg"></p><p>上图结论：必须找出一种方法来区分哪些计算机属于同一广播域，哪些不是，如果是就采用广播的方式发送，如果不是，</p><p>就采用路由的方式（向不同广播域／子网分发数据包），mac地址是无法区分的，它只跟厂商有关</p><p>网络层功能：引入一套新的地址用来区分不同的广播域／子网，这套地址即网络地址</p><h4 id="IP协议："><a href="#IP协议：" class="headerlink" title="IP协议："></a>IP协议：</h4><ul><li>规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4，它规定网络地址由32位2进制表示</li><li>范围0.0.0.0-255.255.255.255</li><li>一个ip地址通常写成四段十进制数，例：172.16.10.1</li></ul><h4 id="ip地址分成两部分"><a href="#ip地址分成两部分" class="headerlink" title="ip地址分成两部分"></a>ip地址分成两部分</h4><ul><li>网络部分：标识子网</li><li>主机部分：标识主机</li></ul><p>注意：单纯的ip地址段只是标识了ip地址的种类，从网络部分或主机部分都无法辨识一个ip所处的子网</p><p>例：172.16.10.1与172.16.10.2并不能确定二者处于同一子网</p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.10.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p><p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p><p>比如，已知IP地址172.16.10.1和172.16.10.2的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，</p><p>172.16.10.1：10101100.00010000.00001010.000000001</p><p>255255.255.255.0:11111111.11111111.11111111.00000000</p><p>AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0</p><p>172.16.10.2：10101100.00010000.00001010.000000010</p><p>255255.255.255.0:11111111.11111111.11111111.00000000</p><p>AND运算得网络地址结果：10101100.00010000.00001010.000000001-&gt;172.16.10.0</p><p>结果都是172.16.10.0，因此它们在同一个子网络。</p><p>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p><h4 id="ip数据包"><a href="#ip数据包" class="headerlink" title="ip数据包"></a>ip数据包</h4><p>ip数据包也分为head和data部分，无须为ip包定义单独的栏位，直接放入以太网包的data部分</p><p>head：长度为20到60字节</p><p>data：最长为65,515字节。</p><p>而以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p><table><thead><tr><th>以太网头</th><th>ip 头</th><th>ip数据</th></tr></thead><tbody><tr><td>head</td><td>ip</td><td>data</td></tr></tbody></table><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>arp协议由来：计算机通信基本靠吼，即广播的方式，所有上层的包到最后都要封装上以太网头，然后通过以太网协议发送，在谈及以太网协议时候，我门了解到</p><p>通信是基于mac的广播方式实现，计算机在发包时，获取自身的mac是容易的，如何获取目标主机的mac，就需要通过arp协议</p><p>arp协议功能：广播的方式发送数据包，获取目标主机的mac地址</p><p>协议工作方式：每台主机ip都是已知的</p><p>例如：主机172.16.10.10&#x2F;24访问172.16.10.11&#x2F;24</p><p>一：首先通过ip地址和子网掩码区分出自己所处的子网</p><table><thead><tr><th>场景</th><th>数据包地址</th></tr></thead><tbody><tr><td>同一子网</td><td>目标主机mac，目标主机ip</td></tr><tr><td>不同子网</td><td>网关mac，目标主机ip</td></tr></tbody></table><p>二：分析172.16.10.10&#x2F;24与172.16.10.11&#x2F;24处于同一网络(如果不是同一网络，那么下表中目标ip为172.16.10.1,通过arp获取的是网关的mac)</p><table><thead><tr><th></th><th>源mac</th><th>目标mac</th><th>源ip</th><th>目标ip</th><th>数据部分</th></tr></thead><tbody><tr><td>发送端主机</td><td>发送端mac</td><td>FF:FF:FF:FF:FF:FF</td><td>172.16.10.10&#x2F;24</td><td>172.16.10.11&#x2F;24</td><td>数据</td></tr></tbody></table><p>三：这个包会以广播的方式在发送端所处的自网内传输，所有主机接收后拆开包，发现目标ip为自己的，就响应，返回自己的mac</p><h3 id="2-4、传输层"><a href="#2-4、传输层" class="headerlink" title="2.4、传输层"></a>2.4、传输层</h3><p>传输层的由来：网络层的ip帮我们区分子网，以太网层的mac帮我们找到主机，然后大家使用的都是应用程序，你的电脑上可能同时开启qq，暴风影音，等多个应用程序，</p><p>那么我们通过ip和mac找到了一台特定的主机，如何标识这台主机上的应用程序，答案就是端口，端口即应用程序与网卡关联的编号。</p><p>传输层功能：建立端口到端口的通信</p><p>补充：端口范围0-65535，0-1023为系统占用端口</p><h4 id="tcp协议："><a href="#tcp协议：" class="headerlink" title="tcp协议："></a>tcp协议：</h4><p>可靠传输，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><table><thead><tr><th>以太网头</th><th>ip 头</th><th>tcp头</th><th>数据</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="udp协议："><a href="#udp协议：" class="headerlink" title="udp协议："></a>udp协议：</h4><p>不可靠传输，”报头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><table><thead><tr><th>以太网头</th><th>ip头</th><th>udp头</th><th>数据</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="tcp三次握手和四次挥手"><a href="#tcp三次握手和四次挥手" class="headerlink" title="tcp三次握手和四次挥手"></a>tcp三次握手和四次挥手</h4><p><img src="/images/wljc7.jpg"></p><h3 id="2-5、应用层"><a href="#2-5、应用层" class="headerlink" title="2.5、应用层"></a>2.5、应用层</h3><p>应用层由来：用户使用的都是应用程序，均工作于应用层，互联网是开发的，大家都可以开发自己的应用程序，数据多种多样，必须规定好数据的组织形式 </p><p>应用层功能：规定应用程序的数据格式。</p><p>例：TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/wljc7.jpg"></p><h2 id="3、dhcp、DNS"><a href="#3、dhcp、DNS" class="headerlink" title="3、dhcp、DNS"></a>3、dhcp、DNS</h2><h4 id="dhcp"><a href="#dhcp" class="headerlink" title="dhcp"></a>dhcp</h4><p> 作用：自动分配IP地址 </p><p>想实现网络通信，每台主机需具备四要素</p><ul><li>本机的IP地址</li><li>子网掩码</li><li>网关的IP地址</li><li>DNS的IP地址</li></ul><p>获取这四要素分两种方式</p><p>1.静态获取</p><p>即手动配置</p><p>2.动态获取</p><p>通过dhcp获取</p><table><thead><tr><th>以太网头</th><th>ip头</th><th>udp头</th><th>dhcp数据包</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>DNS的作用：在互联网中，其实没有类似于<a href="http://www.xxx.com/">www.xxx.com</a>这种域名方式，而替代的是以IP地址，如222.222.222.222，那我们在IE地址栏中应当输入222.222.222.222才能打开网站<a href="http://www.xxx.com,但我们细想一下,互联网上的网站成千上万,如果每个网站登陆都需要记住一大串数字,那是不是特别不方便,对于记忆力不强的人,根本无法记住这么烦琐的数字.这个时候dns就出现了,它的作用就是将222.222.222.222解析为www.xxx.com,那么我们登陆的时候就直接输入域名就可以了./">www.xxx.com，但我们细想一下，互联网上的网站成千上万，如果每个网站登陆都需要记住一大串数字，那是不是特别不方便，对于记忆力不强的人，根本无法记住这么烦琐的数字。这个时候DNS就出现了，它的作用就是将222.222.222.222解析为www.xxx.com，那么我们登陆的时候就直接输入域名就可以了。</a></p><p>为什么一定要设置DNS才能上网？有些朋友可能会发现，为什么我可能登陆QQ、MSN，但却打不开网页呢？其实大部分原因都是因为DNS服务器故障造成的，DNS服务器地址是唯一的，是运营商提供给终端用户用来解析IP地址及域名的关系，而如果不设定DNS服务器地址，那么就无法查询地址的去向，自然也就打不开网页，而QQ、MSN等即时聊天软件，采用的是UDP传输协议，即不可靠传输协议，无需提供DNS服务器地址，也同样可以登陆。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm虚拟机</title>
    <link href="/2022/05/31/java%20jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2022/05/31/java%20jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="jvm虚拟机"><a href="#jvm虚拟机" class="headerlink" title="jvm虚拟机"></a>jvm虚拟机</h2><p>Java 虚拟机屏蔽了与具体操作系统平台相关的信息,使得 Java 语言编译程序只需生成在 Java 虚拟机上运行的目标代码(字节码),就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时,实际上最终还是把字节码解释成具体平台上的机器指令执行。</p><h2 id="Java-的优点"><a href="#Java-的优点" class="headerlink" title="Java 的优点"></a>Java 的优点</h2><ul><li>是一门结构严谨、面向对象的编程语言。</li><li>摆脱了硬件平台的束缚，实现了“一次编写，到处运行”的理想。</li><li>提供了一种相对安全的内存管理和访问机制，避免了绝大部分的内存泄漏和指针越界问题。</li><li>实现了热点代码检测和运行时编译及优化，使得 Java 应用能随着运行时间的增加而获得更高的性能。</li><li>有一套完善的应用程序接口和无数的来自商业机构和开源社区的第三方类库来帮助实现各种各样的功能。</li></ul><h2 id="Java-平台的逻辑结构"><a href="#Java-平台的逻辑结构" class="headerlink" title="Java 平台的逻辑结构"></a>Java 平台的逻辑结构</h2><p><img src="/images/xnj1.webp"></p><ul><li>Java Language    java语音 其实就是我们接触写的java代码</li><li>Tools &amp; Tool APIs      java的一些工具类</li><li>JDK(Java SE Development Kit)，Java标准开发包，它提供了编译、运行Java程序所需的各种工具和资源，包括Java编译器、Java运行时环境，以及常用的Java类库等。</li><li>JRE( Java Runtime Environment) 、Java运行环境，用于解释执行Java的字节码文件。普通用户而只需要安装 JRE（Java Runtime Environment）来运行 Java 程序。而程序开发者必须安装JDK来编译、调试程序。</li><li>JVM(Java Virtual Mechinal)，Java虚拟机，是JRE的一部分。它是整个java实现跨平台的最核心的部分，负责解释执行字节码文件，是可运行java字节码文件的虚拟计算机。所有平台的上的JVM向编译器提供相同的接口，而编译器只需要面向虚拟机，生成虚拟机能识别的代码，然后由虚拟机来解释执行。</li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ul><li>JVM 是一种基于下层的操作系统和硬件平台并利用软件方法来实现的抽象的计算机，可以在上面执行 Java 的字节码程序。简单的说，JVM 就是 Java 的虚拟机,有了 JVM 才能运行 Java 程序。</li><li>Java 编译器只需面向 JVM，生成 JVM 能理解的代码或字节码文件。Java 源文件经编译器，编译成字节码程序，通过 JVM 将每一条指令翻译成不同平台机器码，通过特定平台运行。</li></ul><p><img src="/images/xnj2.png"></p><h3 id="class-文件的组成"><a href="#class-文件的组成" class="headerlink" title="class 文件的组成"></a>class 文件的组成</h3><ul><li>结构信息。包括 class 文件格式版本号及各部分的数量与大小的信息。</li><li>元数据。对应于 Java 源码中声明与常量的信息。包含类&#x2F;继承的超类&#x2F;实现的接口的声明信息、域与方法声明信息和常量池。</li><li>方法信息。对应 Java 源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息。</li></ul><h3 id="类执行机制"><a href="#类执行机制" class="headerlink" title="类执行机制"></a>类执行机制</h3><ul><li>JVM 是基于栈的体系结构来执行 class 字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。</li></ul><h3 id="jvm运行时数据区"><a href="#jvm运行时数据区" class="headerlink" title="jvm运行时数据区"></a>jvm运行时数据区</h3><p><img src="/images/xnj3.png"></p><h4 id="1、程序计数器PC"><a href="#1、程序计数器PC" class="headerlink" title="1、程序计数器PC"></a>1、程序计数器PC</h4><p>1、程序计数器是线程私有的区域,每个线程当然得有个计数器记录当前执行到那个指令。</p><p>2、占用的内存空间小，可以把它看成是当前线程所执行的字节码的行号指示器。如果线程在执行Java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；如果执行的是Native方法，这个计数器的值为空（Undefined）。</p><p>3、此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</p><h4 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h4><p>这个区域也是我们平时口中说的堆栈的栈，关于这个块区域有如下要点：</p><p>1.属于线程私有，与线程的生命周期相同</p><p>2.每一个java方法被执行的时候，这个区域会生成一个栈帧,执行引擎每调用一个函数时，就为这个函数创建一个栈帧，并加入虚拟机栈。换个角度理解，每个函数从调用到执行结束，其实是对应一个栈帧的入栈和出栈</p><p>4.栈帧中存放的局部变量有8种基本数据类型，以及引用类型（对象的内存地址）</p><p>5.当线程请求的栈的深度超出了虚拟机栈允许的深度时，会抛出StackOverFlow的错误</p><p>6.当Java虚拟机动态扩展到无法申请足够内存时会抛出OutOfMemory的错误</p><h4 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h4><p>类似于这样:System.arraycopy()调用c里面的方法</p><p>memcpy(void *destin, void *source, unsigned n)</p><h4 id="4、方法区"><a href="#4、方法区" class="headerlink" title="4、方法区"></a>4、方法区</h4><p>1.方法区存放的是类信息、常量、静态变量等。</p><p>2.方法区是各个线程共享区域，很容易理解，我们在写Java代码时，每个线程度可以访问同一个类的静态变量对象。由于使用反射机制的原因，虚拟机很难推测那个类信息不再使用，因此这块区域的回收很难。</p><p>3.另外，对这块区域主要是针对常量池回收，值得注意的是JDK1.7已经把常量池转移到堆里面了。</p><p>4.同样，当方法区无法满足内存分配需求时，会抛出OutOfMemoryError。</p><h4 id="5、Java堆"><a href="#5、Java堆" class="headerlink" title="5、Java堆"></a>5、Java堆</h4><p>我们平时说得最多，关注得最多的一个区域，new 出来的对象，就存放在这里！我们后期进行的性能优化主要针对这部分内存，GC的主战场，这个地方存放的几乎所有的对象实例和数组数据。这里我大概进行了如下概括：</p><p>1.由于现在的收集器基本上采用的都是分代收集算法，所有Java堆可以细分为：新生代和老年代。再细致分就是把新生代分为：Eden空间、From Survivor空间、To Survivor空间。</p><p>2.当堆无法再扩展时，会抛出OutOfMemoryError异常。</p><h5 id="Java堆内存结构"><a href="#Java堆内存结构" class="headerlink" title="Java堆内存结构"></a>Java堆内存结构</h5><p>为了后面章节知识点的理解，我们应该先对Java堆内存结构划分有一定的了解。Java将堆内存分为3大部分：新生代、老年代和永久代，其中新生代又进一步划分为Eden、S0、S1(Survivor)三个区。结构如下图所示：</p><p>+—————————+——————————-+——————-+</p><p>|          |       |        |                               |                   |</p><p>|   Eden   |   S0  |   S1   |       Old generation          |      Perm         |</p><p>|          |       |        |                               |                   |</p><p>+—————————+——————————-+——————-+</p><p>|&lt;—-Young Gen Space——&gt;|</p><p>我们在程序中new出来的对象一般情况下都会在新生代里的Eden区里面分配空间，如果存活时间足够长将会进入Survivor区，进而如果存活时间再长，还会被提升分配到老年代里面。持久代里面存放的是Class类元数据、方法描述等。</p><h2 id="分代回收算法"><a href="#分代回收算法" class="headerlink" title="分代回收算法"></a>分代回收算法</h2><p>我们一般讨论的垃圾回收主要针对Java堆内存中的新生代和老年代，也正因为新生代和老年代结构上的不同，所以产生了分代回收算法，即新生代的垃圾回收和老年代的垃圾回收采用的是不同的回收算法。针对新生代，主要采用复制算法，而针对老年代，通常采用标记-清除算法或者标记-整理算法来进行回收。</p><h3 id="1、-清除算法"><a href="#1、-清除算法" class="headerlink" title="1、 清除算法"></a>1、 清除算法</h3><p><img src="/images/xnj4.png"></p><p>标记清除算法（Mark-Sweep）是最基础的一种垃圾回收算法，它分为2部分，先把内存区域中的这些对象进行标记，哪些属于可回收标记出来，然后把这些垃圾拎出来清理掉。就像上图一样，清理掉的垃圾就变成未使用的内存区域，等待被再次使用。</p><p>这逻辑再清晰不过了，并且也很好操作，但它存在一个很大的问题，那就是内存碎片。</p><p>上图中等方块的假设是 2M，小一些的是 1M，大一些的是 4M。等我们回收完，内存就会切成了很多段。我们知道开辟内存空间时，需要的是连续的内存区域，这时候我们需要一个 2M的内存区域，其中有2个 1M 是没法用的。这样就导致，其实我们本身还有这么多的内存的，但却用不了。</p><h3 id="2、复制算法"><a href="#2、复制算法" class="headerlink" title="2、复制算法"></a>2、复制算法</h3><p><img src="/images/xnj5.png"></p><p>复制算法（Copying）是在标记清除算法上演化而来，解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况，逻辑清晰，运行高效。</p><p>上面的图很清楚，也很明显的暴露了另一个问题，合着我这140平的大三房，只能当70平米的小两房来使？代价实在太高。</p><h3 id="3、标记整理算法"><a href="#3、标记整理算法" class="headerlink" title="3、标记整理算法"></a>3、标记整理算法</h3><p><img src="/images/xnj6.png"></p><p>标记整理算法（Mark-Compact）标记过程仍然与标记 — 清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。</p><p>标记整理算法一方面在标记-清除算法上做了升级，解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。看起来很美好，但从上图可以看到，它对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多。</p><p>分代收集算法分代收集算法（Generational Collection）严格来说并不是一种思想或理论，而是融合上述3种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或者标记 — 整理算法来进行回收。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 搭建个人博客</title>
    <link href="/2022/05/31/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/05/31/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo-介绍"><a href="#Hexo-介绍" class="headerlink" title="Hexo 介绍"></a>Hexo 介绍</h2><p>Hexo是一个基于 node.js的快速生成静态博客的开源框架,支持 Markdown和大多数 Octopress<br>插件,一个命令即可部署到 Github页面、 Giteee、 Heroku等,强大的APl,可无限扩展,拥有<br>数百个主题和插件。 </p><p>简单来说就是开始生成一套你个人的博客网站</p><p>官方文档：<a href="https://hexo.io/zh-cn/docs/front-matter">https://hexo.io/zh-cn/docs/front-matter</a></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="1、安装Node-js"><a href="#1、安装Node-js" class="headerlink" title="1、安装Node.js"></a>1、安装Node.js</h3><p>直接到官网上下载安装即可<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li>Node自带npm</li></ul><h3 id="2、安装Git"><a href="#2、安装Git" class="headerlink" title="2、安装Git"></a>2、安装Git</h3><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>.</li></ul><h2 id="开始安装Hexo"><a href="#开始安装Hexo" class="headerlink" title="开始安装Hexo"></a>开始安装Hexo</h2><h3 id="1、安装hexo"><a href="#1、安装hexo" class="headerlink" title="1、安装hexo"></a>1、安装hexo</h3><p> 你可以先创建一个文件夹blog，然后<code>cd</code>到这个文件夹下 </p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span> <br></code></pre></td></tr></table></figure><p> 用<code>hexo -v</code>查看一下版本 </p><h3 id="2、初始化hexo，新建存储博客的文件夹"><a href="#2、初始化hexo，新建存储博客的文件夹" class="headerlink" title="2、初始化hexo，新建存储博客的文件夹"></a>2、初始化hexo，新建存储博客的文件夹</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span> myblog<br></code></pre></td></tr></table></figure><h3 id="3、进入文件夹，安装一下npm"><a href="#3、进入文件夹，安装一下npm" class="headerlink" title="3、进入文件夹，安装一下npm"></a>3、进入文件夹，安装一下npm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> myblog<br>npm install<br></code></pre></td></tr></table></figure><p> 可以看到我们的hexo站点就已经安装好了，接下来就可以直接启动他了 </p><p>新建完成后，指定文件夹目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>** _config.yml: 博客的配置文件**</li></ul><h3 id="4、启动服务站点"><a href="#4、启动服务站点" class="headerlink" title="4、启动服务站点"></a>4、启动服务站点</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo g <br>hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p> 打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。 </p><p><img src="/images/grbk1.jpg"></p><h2 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h2><p>首先，你先要有一个GitHub账户，去注册一个吧。</p><p>注册完登录后，在GitHub.com中看到一个New repository，新建仓库</p><p><img src="/images/grbk2.jpg"></p><p> 创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我这里是已经建过了。 </p><p><img src="/images/grbk3.jpg"></p><h2 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h2><p>回到你的git bash中，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;yourname&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;youremail&quot;</span><br>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。<br></code></pre></td></tr></table></figure><p>可以用以下两条，检查一下你有没有输对</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git config <span class="hljs-keyword">user</span>.name<br>git config <span class="hljs-keyword">user</span>.email<br></code></pre></td></tr></table></figure><p>然后创建SSH,一路回车</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></td></tr></table></figure><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。</p><p><img src="/images/grbk4.jpg"></p><p>ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p><p>而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key<br>把你的id_rsa.pub里面的信息复制进去。</p><p><img src="/images/grbk5.jpg"></p><p>在gitbash中，查看是否成功</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com <br></code></pre></td></tr></table></figure><h2 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h2><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为<br>YourgithubName就是你的GitHub账户</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/YourgithubName/YourgithubName.github.io.git</span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>然后</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo clean<br>hexo <span class="hljs-keyword">generate</span><br>hexo deploy<br></code></pre></td></tr></table></figure><p>其中 hexo clean清除了你之前生成的东西，也可以不加。<br>hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写<br>hexo deploy 部署文章，可以用hexo d缩写</p><p>注意deploy时可能要你输入username和password。</p><p>得到下图就说明部署成功了，过一会儿就可以在<a href="https://fxn-sm.github.io/">https://fxn-sm.github.io</a> 这个网站看到你的博客了！！</p><p><img src="/images/grbk6.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>搭建个人博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo更换主题</title>
    <link href="/2022/05/31/hexo%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98/"/>
    <url>/2022/05/31/hexo%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一款-Material-Design-风格的主题"><a href="#一款-Material-Design-风格的主题" class="headerlink" title="一款 Material Design 风格的主题"></a>一款 Material Design 风格的主题</h1><p>github地址：<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>官方文档：<a href="https://hexo.fluid-dev.com/docs/start/">https://hexo.fluid-dev.com/docs/start/</a></p><h2 id="快速配置"><a href="#快速配置" class="headerlink" title="快速配置"></a>快速配置</h2><h3 id="1、集成"><a href="#1、集成" class="headerlink" title="1、集成"></a>1、集成</h3><p>Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure><p> 然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml</a> 内容复制进去。 </p><h3 id="2、指定主题"><a href="#2、指定主题" class="headerlink" title="2、指定主题"></a>2、指定主题</h3><p>如下修改 Hexo 博客目录中的 <code>_config.yml</code>：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid  <span class="hljs-meta"># 指定主题</span><br><br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN  <span class="hljs-meta"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><h3 id="3-创建「关于页」"><a href="#3-创建「关于页」" class="headerlink" title="3. 创建「关于页」"></a>3. 创建「关于页」</h3><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> about<br></code></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里写关于页的正文，支持</span> <span class="hljs-string">Markdown,</span> <span class="hljs-string">HTML</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>搭建个人博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
